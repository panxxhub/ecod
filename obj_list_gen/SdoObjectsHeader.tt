<#@ output extension=".h" #>
<#@ template language="C#" #>
// clang-format off
/**
 * THIS FILE IS AUTO GENERATED 
 * GENERATED AT <#= $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}" #>
 * !!! DO NOT EDIT IT !!!
 */

#ifndef __ZEPHYR_SDO_OBJECTS_H__
#define __ZEPHYR_SDO_OBJECTS_H__

#ifdef __linux__
#define ALWAYS_INLINE
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
struct fs_file_t {
  FILE *file_p;
};
#else
#include <zephyr/fs/fs.h>
#include <zephyr/kernel.h>
#endif


typedef struct obj_desc {
	uint16_t subindex;
	uint16_t datatype;
	uint16_t bitlength;
	uint16_t flags;
	const char *name;
	uint32_t value;
	uint8_t *data; // used for visible string type
} obj_desc_t;

typedef struct obj_list {
	uint16_t index;
	uint16_t objtype;
	uint8_t maxsub;
	uint8_t pad1;
	const char *name;
	const obj_desc_t *const objdesc;
} obj_list_t;

typedef struct sm_map {
	const obj_desc_t *obj_desc;
	const obj_list_t *obj_list_items;
	uint32_t offset;
} sm_map_t;

#define OBJH_READ  0
#define OBJH_WRITE 1

#define OTYPE_DOMAIN    0x0002
#define OTYPE_DEFTYPE   0x0005
#define OTYPE_DEFSTRUCT 0x0006
#define OTYPE_VAR       0x0007
#define OTYPE_ARRAY     0x0008
#define OTYPE_RECORD    0x0009

#define DTYPE_BOOLEAN        0x0001
#define DTYPE_INTEGER8       0x0002
#define DTYPE_INTEGER16      0x0003
#define DTYPE_INTEGER32      0x0004
#define DTYPE_UNSIGNED8      0x0005
#define DTYPE_UNSIGNED16     0x0006
#define DTYPE_UNSIGNED32     0x0007
#define DTYPE_REAL32         0x0008
#define DTYPE_VISIBLE_STRING 0x0009
#define DTYPE_OCTET_STRING   0x000A
#define DTYPE_UNICODE_STRING 0x000B
#define DTYPE_INTEGER24      0x0010
#define DTYPE_UNSIGNED24     0x0016
#define DTYPE_INTEGER64      0x0015
#define DTYPE_UNSIGNED64     0x001B
#define DTYPE_REAL64         0x0011
#define DTYPE_PDO_MAPPING    0x0021
#define DTYPE_IDENTITY       0x0023
#define DTYPE_BITARR8        0x002D
#define DTYPE_BITARR16       0x002E
#define DTYPE_BITARR32       0x002F
#define DTYPE_BIT1           0x0030
#define DTYPE_BIT2           0x0031
#define DTYPE_BIT3           0x0032
#define DTYPE_BIT4           0x0033
#define DTYPE_BIT5           0x0034
#define DTYPE_BIT6           0x0035
#define DTYPE_BIT7           0x0036
#define DTYPE_BIT8           0x0037
#define DTYPE_ARRAY_OF_INT   0x0260
#define DTYPE_ARRAY_OF_SINT  0x0261
#define DTYPE_ARRAY_OF_DINT  0x0262
#define DTYPE_ARRAY_OF_UDINT 0x0263

#define ATYPE_Rpre    0x01
#define ATYPE_Rsafe   0x02
#define ATYPE_Rop     0x04
#define ATYPE_Wpre    0x08
#define ATYPE_Wsafe   0x10
#define ATYPE_Wop     0x20
#define ATYPE_RXPDO   0x40
#define ATYPE_TXPDO   0x80
#define ATYPE_BACKUP  0x100
#define ATYPE_SETTING 0x200

#define ATYPE_RO         (ATYPE_Rpre | ATYPE_Rsafe | ATYPE_Rop)
#define ATYPE_WO         (ATYPE_Wpre | ATYPE_Wsafe | ATYPE_Wop)
#define ATYPE_RW         (ATYPE_RO | ATYPE_WO)
#define ATYPE_RWpre      (ATYPE_Wpre | ATYPE_RO)
#define ATYPE_RWop       (ATYPE_Wop | ATYPE_RO)
#define ATYPE_RWpre_safe (ATYPE_Wpre | ATYPE_Wsafe | ATYPE_RO)

/******************************************************************************************
 *  EXPOSED OBJECTS DEFINITIONS
 *****************************************************************************************/
<# 	///<summary> 
	/// SDO OBJECT VAR
	///</summary>
	foreach(var item in ctx.SdoObjVarToExpose) {
		var typeDef = item.TypeDef;
#>
typedef <#= typeDef #>; 
<#
}
#>

<# 	///<summary> 
	///sdo object record
	///</summary>
	foreach(var item in ctx.SdoObjRecordToExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		foreach(var e in item.Entries) {
			if(e.DataRef == "NULL")
				continue;
			var type_entry = e.RecordTypeEntry;
#>
  <#= type_entry #>;
<#
		} // end of foreach(var e in item.Entries)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjRecordToExpose)
#>

<#
	///<summary>
	/// SDO OBJECT ARRAY
	///</summary>
	foreach(var item in ctx.SdoObjArrayToExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		var entriesCount = item.Entries.Count;
		for(int sub_idx = 0; sub_idx < entriesCount; sub_idx++) {
			if(sub_idx == 0 && item.Entries[sub_idx].DataRef == "NULL") {
				continue;
			} 
			if(sub_idx > 1) {
				continue;
			}
			var type_entry = sub_idx == 0 ? item.Entries[sub_idx].RecordTypeEntry : $"const {item.Entries[sub_idx].ArrayTypeEntry}[{entriesCount-1}]";
#>
  <#= type_entry #>;
<#
		} // end of for(int sub_idx = 0; sub_idx < item.Entries.Count; sub_idx++)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjArrayToExpose)
#>



/******************************************************************************************
 *  OBJECT LIST(S) FOR THE SDO SERVER
 *****************************************************************************************/
extern const obj_list_t sdo_objects[];
<#
	foreach(var item in ctx.SdoObjectsToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
		// var is_var = item is SdoObjVar;
		var index = item.Index;
		var name = item.Name;
#>

/** SDO Object <#= $"0x{index:X4}" #> 
 * <#= name #>
 */
extern <#= type_name #> <#= inst #>;
<#
	} // end of foreach(var item in ctx.SdoObjectsToExpose)
#>

/******************************************************************************************
 * SDO_OBJECTS HELPERS
 *****************************************************************************************/
#define SDO_OBJECTS_COUNT 		<#= ctx.SdoObjectsCount #>
#define SDO_OBJECTS_COUNT_LOG2UP	<#= ctx.SdoObjectsCountLog2Up #>

/** Search for an object index matching the wanted value in the Object List.
 * Search in a binary-search fashion.
 * @param[in] index   = value on index of object we want to locate
 * @return local array index if we succeed, -1 if we didn't find the index.
 */
static ALWAYS_INLINE int32_t sdo_find_object(uint16_t index)
{
#define SDO_BINARY_SEARCH_LOW_INIT  0
#define SDO_BINARY_SEARCH_MID_INIT  <#= ctx.SdoObjectsCount/2 #>
#define SDO_BINARY_SEARCH_HIGH_INIT <#= ctx.SdoObjectsCount-1 #>
	int low =  SDO_BINARY_SEARCH_LOW_INIT;
	int high = SDO_BINARY_SEARCH_HIGH_INIT;
	int mid =  SDO_BINARY_SEARCH_MID_INIT;
	for(int iter = 0; iter < SDO_OBJECTS_COUNT_LOG2UP; iter++) {
		if (sdo_objects[mid].index == index) {
			return mid;
		} else if (sdo_objects[mid].index < index) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

/** Search for an object sub-index.
 *
 * @param[in] nidx   = local array index of object we want to find sub-index to
 * @param[in] subindex   = value on sub-index of object we want to locate
 * @return index(<<16) and sub-index if we succeed, -1 if we didn't find the index.
 */
static ALWAYS_INLINE uint32_t sdo_find_subindex(int32_t nidx, uint8_t subindex)
{
	int16_t n = sdo_find_object(nidx);
	if(n < 0) {
		return -1;
	}
	int16_t max_sub = sdo_objects[n].maxsub;
	int low = 0;
	int high = max_sub - 1;
	int mid = (low + high) / 2;
	for(int iter = 0; iter < 6; iter++) {
		const obj_desc_t *const objd = &sdo_objects[n].objdesc[mid];
		if (objd->subindex == subindex) {
			return n << 16 | mid;
		} else if (objd->subindex < subindex) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

#if defined __cplusplus
extern "C" {
#endif /* __cplusplus */

/**
 * Restore the default values of the SDO objects.
 * This function is called when the device is reset.
 *
 * @brief, for non-volatile objects, the default values are stored at the static object declaration.
 */
void sdo_restore_defaults(void);


/**
 * Restore the default values of the SDO objects with the given index.
 *
 * @param[in] index = index of the object to restore
 */
void sdo_restore_defaults_index(uint16_t index);


/**
 * Restore the default values of the SDO objects with the given index and sub-index.
 *
 * @param[in] index = index of the object to restore
 * @param[in] subindex = sub-index of the object to restore
 */
void sdo_restore_defaults_subindex(uint16_t index, uint8_t subindex);

/**
 * Load the SDO objects from the non-volatile storage.
 * This function is called when the user called the function to save all the configuration to the non-volatile storage.
 */
void sdo_objects_save_to_storage(struct fs_file_t *file);

/**
 * @brief Save the SDO object with the given index and subindex to the non-volatile storage.
 * 
 * @param file 
 * @param index 
 * @param subindex 
 * @return int, 0 if success, -1 if failed
 */
int sdo_object_save_to_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex);


/**
 * Initialize the SDO objects from the non-volatile storage.
 * This function is called when the device is powered on.
 */
void sdo_objects_init_from_storage(struct fs_file_t *file);

/**
 * @brief Load sdo entry from index-subindex pair   
 * 
 * @param file 
 * @param index 
 * @param subindex 
 * @return int 
 */
int sdo_object_load_from_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex);

/**
 * @brief
 *
 * @param[in] index = SM index
 * @param[out] n_mappings = number of mapped objects in SM, or -1 if mapping is invalid
 * @param[out] mappings = list of mapped objects in SM
 * @param[out] max_mappings = maximum number of mappings in SM
 * @return size of RxPDO or TxPDO in bytes.
 */
uint16_t size_of_pdo(uint16_t index, int *n_mappings, sm_map_t *mappings, int max_mappings);


#if defined __cplusplus
}
#endif /* __cplusplus */

#define SDO_NON_VOLATILE_FILE_SIZE <#= $"0x{ctx.NonVolatileFileSize:X8}" #>

#endif /* __ZEPHYR_SDO_OBJECTS_H__ */
// clang-format on