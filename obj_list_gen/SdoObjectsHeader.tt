<#@ output extension=".h" #>
<#@ template language="C#" #>
// clang-format off
/**
 * THIS FILE IS AUTO GENERATED 
 * GENERATED AT <#= $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}" #>
 * !!! DO NOT EDIT IT !!!
 */

#ifndef __ZEPHYR_SDO_OBJECTS_H__
#define __ZEPHYR_SDO_OBJECTS_H__

#include <stdint.h>
#include <string.h>
#ifdef __linux__
#define ALWAYS_INLINE
#include <stdbool.h>
#include <stdio.h>
struct fs_file_t {
  FILE *file_p;
};
#else
#include <zephyr/fs/fs.h>
#include <zephyr/kernel.h>
#endif

typedef struct obj_desc {
	uint16_t subindex;
	uint16_t datatype;
	uint16_t bitlength;
	uint16_t flags;
	const char * name;
	const uint32_t name_size;
	uint32_t value;
	uint8_t *data; // used for visible string type
} obj_desc_t;

typedef struct obj_list {
	uint16_t index;
	uint16_t objtype;
	uint8_t maxsub;
	uint8_t pad1;
	const char * name;
	const uint32_t name_size;
	const obj_desc_t *const objdesc;
} obj_list_t;

typedef struct sm_map {
	const obj_desc_t *obj_desc;
	const obj_list_t *obj_list_items;
	uint32_t offset;
} sm_map_t;

#define OBJH_READ  0
#define OBJH_WRITE 1

#define OTYPE_DOMAIN    0x0002
#define OTYPE_DEFTYPE   0x0005
#define OTYPE_DEFSTRUCT 0x0006
#define OTYPE_VAR       0x0007
#define OTYPE_ARRAY     0x0008
#define OTYPE_RECORD    0x0009

#define DTYPE_BOOLEAN        0x0001
#define DTYPE_INTEGER8       0x0002
#define DTYPE_INTEGER16      0x0003
#define DTYPE_INTEGER32      0x0004
#define DTYPE_UNSIGNED8      0x0005
#define DTYPE_UNSIGNED16     0x0006
#define DTYPE_UNSIGNED32     0x0007
#define DTYPE_REAL32         0x0008
#define DTYPE_VISIBLE_STRING 0x0009
#define DTYPE_OCTET_STRING   0x000A
#define DTYPE_UNICODE_STRING 0x000B
#define DTYPE_INTEGER24      0x0010
#define DTYPE_UNSIGNED24     0x0016
#define DTYPE_INTEGER64      0x0015
#define DTYPE_UNSIGNED64     0x001B
#define DTYPE_REAL64         0x0011
#define DTYPE_PDO_MAPPING    0x0021
#define DTYPE_IDENTITY       0x0023
#define DTYPE_BITARR8        0x002D
#define DTYPE_BITARR16       0x002E
#define DTYPE_BITARR32       0x002F
#define DTYPE_BIT1           0x0030
#define DTYPE_BIT2           0x0031
#define DTYPE_BIT3           0x0032
#define DTYPE_BIT4           0x0033
#define DTYPE_BIT5           0x0034
#define DTYPE_BIT6           0x0035
#define DTYPE_BIT7           0x0036
#define DTYPE_BIT8           0x0037
#define DTYPE_ARRAY_OF_INT   0x0260
#define DTYPE_ARRAY_OF_SINT  0x0261
#define DTYPE_ARRAY_OF_DINT  0x0262
#define DTYPE_ARRAY_OF_UDINT 0x0263

#define ATYPE_Rpre    0x01
#define ATYPE_Rsafe   0x02
#define ATYPE_Rop     0x04
#define ATYPE_Wpre    0x08
#define ATYPE_Wsafe   0x10
#define ATYPE_Wop     0x20
#define ATYPE_RXPDO   0x40
#define ATYPE_TXPDO   0x80
#define ATYPE_BACKUP  0x100
#define ATYPE_SETTING 0x200

#define ATYPE_RO         (ATYPE_Rpre | ATYPE_Rsafe | ATYPE_Rop)
#define ATYPE_WO         (ATYPE_Wpre | ATYPE_Wsafe | ATYPE_Wop)
#define ATYPE_RW         (ATYPE_RO | ATYPE_WO)
#define ATYPE_RWpre      (ATYPE_Wpre | ATYPE_RO)
#define ATYPE_RWop       (ATYPE_Wop | ATYPE_RO)
#define ATYPE_RWpre_safe (ATYPE_Wpre | ATYPE_Wsafe | ATYPE_RO)

#define BITS2BYTES(b) ((b + 7U) >> 3)
#define BITSPOS2BYTESOFFSET(b) (b >> 3)

/******************************************************************************************
 *  EXPOSED OBJECTS DEFINITIONS
 *****************************************************************************************/
<# 	///<summary> 
	/// SDO OBJECT VAR
	///</summary>
	foreach(var item in ctx.SdoObjVarToExpose) {
		var typeDef = item.TypeDef;
#>
typedef <#= typeDef #>; 
<#
}
#>

<# 	///<summary> 
	///sdo object record
	///</summary>
	foreach(var item in ctx.SdoObjRecordToExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		foreach(var e in item.Entries) {
			if(e.DataRef == "NULL")
				continue;
			var type_entry = e.RecordTypeEntry;
#>
  <#= type_entry #>;
<#
		} // end of foreach(var e in item.Entries)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjRecordToExpose)
#>

<#
	///<summary>
	/// SDO OBJECT ARRAY
	///</summary>
	foreach(var item in ctx.SdoObjArrayToExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		var entriesCount = item.Entries.Count;
		for(int sub_idx = 0; sub_idx < entriesCount; sub_idx++) {
			if(sub_idx == 0 && item.Entries[sub_idx].DataRef == "NULL") {
				continue;
			} 
			if(sub_idx > 1) {
				continue;
			}
			var type_entry = sub_idx == 0 ? item.Entries[sub_idx].RecordTypeEntry : $"const {item.Entries[sub_idx].ArrayTypeEntry}[{entriesCount-1}]";
#>
  <#= type_entry #>;
<#
		} // end of for(int sub_idx = 0; sub_idx < item.Entries.Count; sub_idx++)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjArrayToExpose)
#>



/******************************************************************************************
 *  OBJECT LIST(S) FOR THE SDO SERVER
 *****************************************************************************************/
extern const obj_list_t sdo_objects[];
<#
	foreach(var item in ctx.SdoObjectsToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
		// var is_var = item is SdoObjVar;
		var index = item.Index;
		var name = item.Name;
#>

/** SDO Object <#= $"0x{index:X4}" #> 
 * <#= name #>
 */
extern <#= type_name #> <#= inst #>;
<#
	} // end of foreach(var item in ctx.SdoObjectsToExpose)
#>

/******************************************************************************************
 * SDO_OBJECTS HELPERS
 *****************************************************************************************/
#define SDO_OBJECTS_COUNT 		<#= ctx.SdoObjectsCount #>
#define SDO_OBJECTS_COUNT_LOG2UP	<#= ctx.SdoObjectsCountLog2Up #>

/** Search for an object index matching the wanted value in the Object List.
 * Search in a binary-search fashion.
 * @param[in] index   = value on index of object we want to locate
 * @return local array index if we succeed, -1 if we didn't find the index.
 */
static ALWAYS_INLINE int32_t sdo_find_object(uint16_t index)
{
#define SDO_BINARY_SEARCH_LOW_INIT  0
#define SDO_BINARY_SEARCH_MID_INIT  <#= ctx.SdoObjectsCount/2 #>
#define SDO_BINARY_SEARCH_HIGH_INIT <#= ctx.SdoObjectsCount-1 #>
	int low =  SDO_BINARY_SEARCH_LOW_INIT;
	int high = SDO_BINARY_SEARCH_HIGH_INIT;
	int mid =  SDO_BINARY_SEARCH_MID_INIT;
	for(int iter = 0; iter < SDO_OBJECTS_COUNT_LOG2UP; iter++) {
		if (sdo_objects[mid].index == index) {
			return mid;
		} else if (sdo_objects[mid].index < index) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

/** Search for an object sub-index.
 *
 * @param[in] nidx   = local array index of object we want to find sub-index to
 * @param[in] subindex   = value on sub-index of object we want to locate
 * @return index(<<16) and sub-index if we succeed, -1 if we didn't find the index.
 */
static ALWAYS_INLINE uint32_t sdo_find_subindex(int32_t nidx, uint8_t subindex)
{
	int16_t n = sdo_find_object(nidx);
	if(n < 0) {
		return -1;
	}
	int16_t max_sub = sdo_objects[n].maxsub;
	int low = 0;
	int high = max_sub - 1;
	int mid = (low + high) / 2;
	for(int iter = 0; iter < 6; iter++) {
		const obj_desc_t *const objd = &sdo_objects[n].objdesc[mid];
		if (objd->subindex == subindex) {
			return n << 16 | mid;
		} else if (objd->subindex < subindex) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

static ALWAYS_INLINE uint64_t sdo_get_value(const obj_desc_t *obj)
{
	uint64_t value = 0;

	switch (obj->datatype) {

	case DTYPE_BIT1:
	case DTYPE_BIT2:
	case DTYPE_BIT3:
	case DTYPE_BIT4:
	case DTYPE_BIT5:
	case DTYPE_BIT6:
	case DTYPE_BIT7:
	case DTYPE_BIT8:
	case DTYPE_BOOLEAN:
	case DTYPE_UNSIGNED8:
	case DTYPE_INTEGER8:
	case DTYPE_BITARR8:
		value = *(uint8_t *)obj->data;
		break;
	case DTYPE_UNSIGNED16:
	case DTYPE_INTEGER16:
	case DTYPE_BITARR16:
		value = *(uint16_t *)obj->data;
		break;

	case DTYPE_REAL32:
	case DTYPE_UNSIGNED32:
	case DTYPE_INTEGER32:
	case DTYPE_BITARR32:
		value = *(uint32_t *)obj->data;
		break;

	case DTYPE_REAL64:
	case DTYPE_UNSIGNED64:
	case DTYPE_INTEGER64:
		/* FIXME: must be atomic */
		value = *(uint64_t *)obj->data;
		break;

	default:
		break;
	}

	return value;
}

static ALWAYS_INLINE void sdo_set_value(const obj_desc_t *obj, uint64_t value)
{
	switch (obj->datatype) {

	case DTYPE_BIT1:
	case DTYPE_BIT2:
	case DTYPE_BIT3:
	case DTYPE_BIT4:
	case DTYPE_BIT5:
	case DTYPE_BIT6:
	case DTYPE_BIT7:
	case DTYPE_BIT8:
	case DTYPE_BOOLEAN:
	case DTYPE_UNSIGNED8:
	case DTYPE_INTEGER8:
	case DTYPE_BITARR8:
		*(uint8_t *)obj->data = value & UINT8_MAX;
		break;
	case DTYPE_UNSIGNED16:
	case DTYPE_INTEGER16:
	case DTYPE_BITARR16:
		*(uint16_t *)obj->data = value & UINT16_MAX;
		break;

	case DTYPE_REAL32:
	case DTYPE_UNSIGNED32:
	case DTYPE_INTEGER32:
	case DTYPE_BITARR32:
		*(uint32_t *)obj->data = value & UINT32_MAX;
		break;

	case DTYPE_REAL64:
	case DTYPE_UNSIGNED64:
	case DTYPE_INTEGER64:
		*(uint64_t *)obj->data = value;
		break;

	default:
		break;
	}
}

/**
 * @brief Get value from a bit slice of a bitmap.
 *
 * @param[in] bitmap = bitmap containing value
 * @param[in] offset = start offset
 * @param[in] length = number of bits to get
 * @return bit_slice value
 */
static ALWAYS_INLINE uint64_t pdo_bit_slice_get(uint64_t *bitmap, unsigned int offset, unsigned int length)
{
	const unsigned int word_offset = offset / 64;
	const unsigned int bit_offset = offset % 64;
	const uint64_t mask = (length == 64) ? UINT64_MAX : ((1ULL << length) - 1);
	uint64_t w0, w1 = 0;

	/* Get the least significant word */
	w0 = bitmap[word_offset] >> bit_offset;

	/* Get the most significant word */
	if (bit_offset + length > 64) {
		w1 = bitmap[word_offset + 1] << (64 - bit_offset);
	}

	return (w1 | w0) & mask;
}

/**
 * @brief Set value to a bit slice of a bitmap.
 *
 * @param[in] bitmap
 * @param[in] offset
 * @param[in] length
 * @param[in] value
 * @return ALWAYS_INLINE
 */
static ALWAYS_INLINE void pdo_bit_slice_set(uint64_t *bitmap, unsigned int offset, unsigned int length, uint64_t value)
{

	const unsigned int word_offset = offset / 64;
	const unsigned int bit_offset = offset % 64;
	const uint64_t mask = (length == 64) ? UINT64_MAX : ((1ULL << length) - 1);

	/* set the least significant word */
	const uint64_t mask0 = mask << bit_offset;
	uint64_t value0 = value << bit_offset;
	uint64_t w0 = (bitmap[word_offset] & ~mask0) | (value0 & mask0);
	bitmap[word_offset] = w0;

	/* set the most significant word */
	if (bit_offset + length > 64) {
		const uint64_t mask1 = mask >> (64 - bit_offset);
		const uint64_t value1 = value >> (64 - bit_offset);
		uint64_t w1 = (bitmap[word_offset + 1] & ~mask1) | (value1 & mask1);
		bitmap[word_offset + 1] = w1;
	}
}

/**
 * @brief
 *
 * @param buffer
 * @param n_mappings
 * @param mappings
 */
static ALWAYS_INLINE void coe_pdo_pack(uint8_t *buffer, int n_mappings, sm_map_t *mappings)
{
	int ix;
	for (ix = 0; ix < n_mappings; ix++) {
		const obj_desc_t *obj = mappings[ix].obj_desc;
		uint32_t offset = mappings[ix].offset;
		if (unlikely(obj != NULL)) {
			if (unlikely(obj->bitlength > 64)) {
				memcpy(&buffer[BITSPOS2BYTESOFFSET(offset)], obj->data, BITS2BYTES(obj->bitlength));
			} else {
				uint64_t value = sdo_get_value(obj);
				pdo_bit_slice_set((uint64_t *)buffer, offset, obj->bitlength, value);
			}
		}
	}
}

/**
 * @brief unpack process data
 *
 * @param[in] buffer = output process data
 * @param[in] n_mappings = number of mappings
 * @param[in] mappings = list of mappings in SM
 * @return ALWAYS_INLINE
 */
static ALWAYS_INLINE void coe_pdo_unpack(uint8_t *buffer, int n_mappings, sm_map_t *mappings)
{

	for (int idx = 0; idx < n_mappings; idx++) {
		const obj_desc_t *obj = mappings[idx].obj_desc;
		uint32_t offset = mappings[idx].offset;

		if (unlikely(obj != NULL)) {
			if (unlikely(obj->bitlength > 64)) {
				memcpy(obj->data, &buffer[BITSPOS2BYTESOFFSET(offset)], BITS2BYTES(obj->bitlength));
			} else {
				uint64_t value = pdo_bit_slice_get((uint64_t *)buffer, offset, obj->bitlength);
				sdo_set_value(obj, value);
			}
		}
	}
}

#if defined __cplusplus
extern "C" {
#endif /* __cplusplus */

/**
 * Restore the default values of the SDO objects.
 * This function is called when the device is reset.
 *
 * @brief, for non-volatile objects, the default values are stored at the static object declaration.
 */
void sdo_restore_defaults(void);


/**
 * Restore the default values of the SDO objects with the given index.
 *
 * @param[in] index = index of the object to restore
 */
void sdo_restore_defaults_index(uint16_t index);


/**
 * Restore the default values of the SDO objects with the given index and sub-index.
 *
 * @param[in] index = index of the object to restore
 * @param[in] subindex = sub-index of the object to restore
 */
void sdo_restore_defaults_subindex(uint16_t index, uint8_t subindex);

/**
 * Load the SDO objects from the non-volatile storage.
 * This function is called when the user called the function to save all the configuration to the non-volatile storage.
 */
void sdo_objects_save_to_storage(struct fs_file_t *file);

/**
 * @brief Save the SDO object with the given index and subindex to the non-volatile storage.
 * 
 * @param file 
 * @param index 
 * @param subindex 
 * @return int, 0 if success, -1 if failed
 */
int sdo_object_save_to_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex);


/**
 * Initialize the SDO objects from the non-volatile storage.
 * This function is called when the device is powered on.
 */
void sdo_objects_init_from_storage(struct fs_file_t *file);

/**
 * @brief Load sdo entry from index-subindex pair   
 * 
 * @param file 
 * @param index 
 * @param subindex 
 * @return int 
 */
int sdo_object_load_from_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex);

/**
 * @brief
 *
 * @param[in] index = SM index
 * @param[out] n_mappings = number of mapped objects in SM, or -1 if mapping is invalid
 * @param[out] mappings = list of mapped objects in SM
 * @param[out] max_mappings = maximum number of mappings in SM
 * @return size of RxPDO or TxPDO in bytes.
 */
uint16_t size_of_pdo(uint16_t index, int *n_mappings, sm_map_t *mappings, int max_mappings);


#if defined __cplusplus
}
#endif /* __cplusplus */

#define SDO_NON_VOLATILE_FILE_SIZE <#= $"0x{ctx.NonVolatileFileSize:X8}" #>

#endif /* __ZEPHYR_SDO_OBJECTS_H__ */
// clang-format on