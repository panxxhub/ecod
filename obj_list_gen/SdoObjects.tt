<#@ output extension=".c" #>
<#@ template language="C#" #>
// clang-format off
/**
 * THIS FILE IS AUTO GENERATED 
 * GENERATED AT <#= $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}" #>
 * !!! DO NOT EDIT IT !!!
 */

#include <sdo/sdo_list.h>

#ifdef __linux__ 
#include <stdio.h>
#include <stddef.h>
#include <unistd.h>
#endif

/******************************************************************************************
 * PRE DEFINED STRINGS
 *****************************************************************************************/
<#
	foreach(var item in ctx.IndexedNames) {
		var key = item.Key;
		var value = item.Value;
		var inst_name = $"str_inst_{value:x4}";
#>
static const char <#= inst_name #>[] = "<#= key #>";
<#
	}
#>

/******************************************************************************************
 * NON-VOLATILE (but not to expose) SDO OBJECT TYPE DEFINITIONS
 *****************************************************************************************/
<# 	///<summary> 
	/// SDO OBJECT VAR
	///</summary>
	foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose) {
		var typeDef = item.TypeDef;
#>
typedef <#= typeDef #>;
<#
}
#>

<# 	///<summary> 
	///sdo object record
	///</summary>
	foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		foreach(var e in item.Entries) {
			if(e.DataRef == "NULL")
				continue;
			var type_entry = e.RecordTypeEntry;
#>
  <#= type_entry #>;
<#
		} // end of foreach(var e in item.Entries)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose)
#>

<#
	///<summary>
	/// SDO OBJECT ARRAY
	///</summary>
	foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		var entriesCount = item.Entries.Count;
		for(int sub_idx = 0; sub_idx < entriesCount; sub_idx++) {
			if(sub_idx==0 && item.Entries[sub_idx].DataRef == "NULL") {
				continue;
			} 
			if(sub_idx>1) {
				continue;
			}
			var type_entry = sub_idx == 0 ? item.Entries[sub_idx].RecordTypeEntry : $"const {item.Entries[sub_idx].ArrayTypeEntry}[{entriesCount-1}]";
#>
  <#= type_entry #>;
<#
		} // end of for(int sub_idx = 0; sub_idx < item.Entries.Count; sub_idx++)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose)
#>

/******************************************************************************************
 * NON-VOLATILE (but not to expose) SDO OBJECT INSTANCE IMPLEMENTATIONS
 *****************************************************************************************/
// sdo var
<#  	// sdo var
	foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = <#= item.Entry.InitValue #>; 
<#
	} // end of foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose)
#>
// sdo records
<# 	// sdo record
	foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = {
<#
		foreach(var sub in item.Entries) {
			if(sub.DataRef == "NULL")
				continue;
			var inst_name = sub.InstName;
			var init_value = sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>
// sdo array
<#	// sdo array
	foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = {
<#
		for(int sub_idx = 0; sub_idx < 2; sub_idx++) {
			var sub = item.GetEntries()[sub_idx];
			if(sub_idx == 0 && sub.DataRef == "NULL") 
				continue;
			var inst_name =  sub_idx == 1 ? "elements" : sub.InstName;
			var init_value = sub_idx == 1 ? item.ArrayElementsInit : sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>


/******************************************************************************************
 * NON-VOLATILE (exposed) SDO OBJECT INSTANCE IMPLEMENTATIONS
 *****************************************************************************************/
// sdo var
<#
	foreach(var item in ctx.SdoObjVarToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
<#= type_name #> <#= inst #> = <#= item.Entry.InitValue #>; 
<#
	} // end of foreach(var item in ctx.SdoObjVarToExpose)
#>

// sdo records
<#
	foreach(var item in ctx.SdoObjRecordToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
<#= type_name #> <#= inst #> = {
<#
		foreach(var sub in item.Entries) {
			if(sub.DataRef == "NULL")
				continue;
			var inst_name = sub.InstName;
			var init_value = sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjRecordToExpose)
#>
// sdo array
<#	// sdo array
	foreach(var item in ctx.SdoObjArrayToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
<#= type_name #> <#= inst #> = {
<#
		for(int sub_idx = 0; sub_idx < 2; sub_idx++) {
			var sub = item.GetEntries()[sub_idx];
			if (sub_idx == 0 && sub.DataRef == "NULL")
				continue;
			var inst_name =  sub_idx == 1 ? "elements" : sub.InstName;
			var init_value = sub_idx == 1 ? item.ArrayElementsInit : sub.InitValue;

#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>


/******************************************************************************************
 * OBJECT DESCRIPTIONS
 *****************************************************************************************/
<#
	foreach(var obj in ctx.SdoObjects) {
		var entries = obj.GetEntries();
#>
const obj_desc_t <#= obj.SdoInstName #>[] = {
<#
		foreach(var e in entries) {
#>
	{ .subindex = <#= $"0x{e.SubIdx:x2}" #>, .datatype= <#= e.CANOpenDataType #>, .bitlength = <#= $"0x{e.BitSize:x2}" #>, .name = <#= e.StrInstName #>, .name_size = <#= e.NameSize #>, .flags = <#= e.AccessType #>, .value = <#= $"0x{e.Value:x8}" #>, .data = <#= e.DataRef #>   },
<#
		} // end of foreach(var e in entries)
#>
};
<#
	} // end of foreach(var obj in ctx.SdoObjects)
#>

/******************************************************************************************
 * PRE-DEFINED RECORDS
 *****************************************************************************************/
const obj_list_t sdo_objects[] = {
<#
	foreach(var item in ctx.SdoObjects) {

#>
  { .index = <#= $"0x{item.Index:x4}" #>, .objtype = <#= item.ObjectType #>, .maxsub = <#= item.MaxSubIndex #>, .pad1 = 0, .name = <#= item.StrInstName #>, .name_size = <#= item.NameSize #>, .objdesc = sdo_<#= $"{item.Index:x4}"#> },
<#
	} // end of foreach(var item in ctx.SdoObjects)
#>
};

/******************************************************************************************
 * SDO ENTRY MAP
 *****************************************************************************************/
typedef struct entry_addr_map {
	uint16_t index;
	uint8_t subindex;
	uint32_t addr;
	ssize_t size;
	uint8_t *const data;
} entry_addr_map_t;

static const entry_addr_map_t sdo_entry_map[] = {
<#
	foreach(var item in ctx.SdoObjectsNonVolatile) {
		var entries = item.GetEntries();
		foreach(var e in entries) {
			var non_volatile = e.NonVolatile;
			if (!non_volatile) {
				continue;
			}
			var size = (int)Math.Ceiling(e.BitSize / 8.0);
#>
	{ .index = <#= $"0x{item.Index:x4}" #>, .subindex = <#= $"0x{e.SubIdx:x2}" #>, .addr = <#=  $"0x{(e.Addr32/8):x4}" #>, .size = <#= $"0x{size:x4}" #>, .data = <#= e.DataRef #> },
<#
		} // end of foreach(var e in entries)
	} // end of foreach(var item in ctx.SdoObjects)
#>
};

#include <string.h>
void sdo_restore_defaults(void)
{
	for (int i = 0; i < SDO_OBJECTS_COUNT; i++) {
		const obj_list_t *const sdo_obj = &sdo_objects[i];
		for (int j = 0; j < sdo_obj->maxsub; j++) {
			const obj_desc_t *const entry = sdo_obj->objdesc + j;
			if (entry->data != NULL) {
				// restore default value
				size_t entry_size = (entry->bitlength + 7) / 8;
				memcpy((void *)entry->data, &entry->value, entry_size);
			}
		}
	}
}

void sdo_restore_defaults_index(uint16_t index)
{
	const obj_list_t *const sdo_obj = &sdo_objects[index];
	for (int j = 0; j < sdo_obj->maxsub; j++) {
		const obj_desc_t *const entry = sdo_obj->objdesc + j;
		if (entry->data != NULL) {
			// restore default value
			size_t entry_size = (entry->bitlength + 7) / 8;
			memcpy((void *)entry->data, &entry->value, entry_size);
		}
	}
}

void sdo_restore_defaults_subindex(uint16_t index, uint8_t subindex)
{
	const obj_list_t *const sdo_obj = &sdo_objects[index];
	const obj_desc_t *const entry = sdo_obj->objdesc + subindex;
	if (entry->data != NULL) {
		// restore default value
		size_t entry_size = (entry->bitlength + 7) / 8;
		memcpy((void *)entry->data, &entry->value, entry_size);
	}
}

void sdo_objects_save_to_storage(struct fs_file_t *file)
{
	for (int i = 0; i < sizeof(sdo_entry_map) / sizeof(entry_addr_map_t); i++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[i];
#ifndef __linux__
		fs_seek(file, entry->addr, FS_SEEK_SET);
		fs_write(file, entry->data, entry->size);
#else
		fseek(file->file_p, entry->addr, SEEK_SET);
		fwrite(entry->data, 1, entry->size, file->file_p);
#endif
	}
}

void sdo_objects_init_from_storage(struct fs_file_t *file)
{
	for (int i = 0; i < sizeof(sdo_entry_map) / sizeof(entry_addr_map_t); i++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[i];
#ifndef __linux__
		fs_seek(file, entry->addr, FS_SEEK_SET);
		fs_read(file, entry->data, entry->size);
#else
		fseek(file->file_p, entry->addr, SEEK_SET);
		fread(entry->data, 1, entry->size, file->file_p);
#endif
	}
}



static ALWAYS_INLINE int16_t search_sdo_map(uint16_t index, uint8_t subindex)
{
	int low = 0; 
	int mid = <#= ctx.SdoEntriesNonVolatileCount/2 #>;
	int high = <#= ctx.SdoEntriesNonVolatileCount-1 #>;

	for (int iter = 0; iter < <#= ctx.SdoEntriesNonVolatileCountLog2Up #>; iter++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[mid];
		if (entry->index == index && entry->subindex == subindex) {
			return mid;
		} else if (entry->index < index || (entry->index == index && entry->subindex < subindex)) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

int sdo_object_save_to_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex)
{
	// find index/subindex in the map
	int16_t sdo_map_idx = search_sdo_map(index, subindex);
	if (sdo_map_idx < 0) {
		return -1;
	}
	const entry_addr_map_t *const entry = &sdo_entry_map[sdo_map_idx];
	int ret = 0;

#ifndef __linux__
	ret = fs_seek(file, entry->addr, FS_SEEK_SET);
#else
	ret = fseek(file->file_p, entry->addr, SEEK_SET);
#endif

	if (ret) {
		goto fail_or_default;
	}

#ifndef __linux__
	ret = fs_write(file, entry->data, entry->size);
#else
	ret = fwrite(entry->data, 1, entry->size, file->file_p);
#endif

fail_or_default:
	return ret;
}

/**
 * @brief Load sdo entry from index-subindex pair
 *
 * @param file
 * @param index
 * @param subindex
 * @return int
 */
int sdo_object_load_from_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex)
{
	int16_t sdo_map_idx = search_sdo_map(index, subindex);
	if (sdo_map_idx < 0) {
		return -1;
	}
	const entry_addr_map_t *const entry = &sdo_entry_map[sdo_map_idx];
	int ret = 0;
#ifndef __linux__
	ret = fs_seek(file, entry->addr, FS_SEEK_SET);
#else
	ret = fseek(file->file_p, entry->addr, SEEK_SET);
#endif
	if (ret) {
		goto fail_or_default;
	}
#ifndef __linux__
	ret = fs_read(file, entry->data, entry->size);
#else
	// ret = read(file->fd, entry->data, entry->size);	
	ret = fread(entry->data, 1, entry->size, file->file_p);
#endif

fail_or_default:
	return ret;
}

#define RX_PDO_IDX 0x1c12
#define TX_PDO_IDX 0x1c13
/* Fetch value from object dictionary */
#define OBJ_VALUE_FETCH(v, o) ((o).data == NULL ? *(__typeof__(v) *)(o).data : (__typeof__(v))(o).value)
uint16_t size_of_pdo(uint16_t index, int *n_mappings, sm_map_t *mappings, int max_mappings)
{
	uint32_t offset = 0;
	int32_t n_idx;
	uint16_t pdo_mapping_obj_idx;
	const obj_desc_t *obj_desc;
	const obj_desc_t *obj_desc_1c1x;
	uint8_t number_of_assigned_pdos, sub_idx, subsub_idx;
	int map_x = 0;

	if ((index != RX_PDO_IDX) && (index != TX_PDO_IDX)) {
		return 0;
	}
	n_idx = sdo_find_object(index);
	if (unlikely(n_idx < 0)) {
		goto fail_or_default;
	}

	if (max_mappings <= 0) {
		*n_mappings = 0;
		goto fail_or_default;
	}

	obj_desc_1c1x = sdo_objects[n_idx].objdesc;
	number_of_assigned_pdos = OBJ_VALUE_FETCH(number_of_assigned_pdos, obj_desc_1c1x[0]);
	if (unlikely(number_of_assigned_pdos == 0)) {
		*n_mappings = -1;
		goto fail_or_default;
	}

	for (sub_idx = 1; sub_idx <= number_of_assigned_pdos; sub_idx++) {
		pdo_mapping_obj_idx = OBJ_VALUE_FETCH(sub_idx, obj_desc_1c1x[sub_idx]);
		int32_t pdo_mapping_obj_nidx = sdo_find_object(pdo_mapping_obj_idx);
		if (pdo_mapping_obj_nidx < 0) {
			*n_mappings = -1;
			goto fail_or_default;
		}

		uint8_t maxsub;
		obj_desc = sdo_objects[pdo_mapping_obj_nidx].objdesc;
		maxsub = OBJ_VALUE_FETCH(maxsub, obj_desc[0]);

		for (subsub_idx = 1; subsub_idx <= maxsub; subsub_idx++) {
			uint32_t value = OBJ_VALUE_FETCH(value, obj_desc[subsub_idx]);
			uint8_t bitlength = value;
			uint16_t element_idx = (uint16_t)(value >> 16);
			uint8_t element_sub_idx = (uint8_t)(value >> 8);
			const obj_desc_t *element_mapping;
			// if(m)
			if (map_x == max_mappings) {
				/* too many mapped objects */
				*n_mappings = -1;
				return 0;
			}

			if (element_idx == 0 && element_sub_idx == 0) {
				/* legal, padding element */
				element_mapping = NULL;
			} else {
				int32_t pdo_entry_nidx = sdo_find_object(element_idx);
				if (pdo_entry_nidx < 0) {
					*n_mappings = -1;
					goto fail_or_default;
				}
				int16_t pdo_subentry_nidx = sdo_find_subindex(pdo_entry_nidx, element_sub_idx);
				if (pdo_subentry_nidx < 0) {
					/* mapped subindex does not exist */
					*n_mappings = -1;
					goto fail_or_default;
				}
				element_mapping = &sdo_objects[n_idx].objdesc[pdo_subentry_nidx];
			}

			mappings[map_x].obj_desc = element_mapping;
			mappings[map_x].obj_list_items = &sdo_objects[n_idx];
			mappings[map_x].offset = offset;
			offset += bitlength;
			map_x++;
		}
	}

fail_or_default:
	return offset;
}

// clang-format on
