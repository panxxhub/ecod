<#@ output extension=".c" #>
<#@ template language="C#" #>
// clang-format off
/**
 * THIS FILE IS AUTO GENERATED 
 * GENERATED AT <#= $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}" #>
 * !!! DO NOT EDIT IT !!!
 */

#include <sdo/sdo_list.h>

#ifndef ZEPHYR_VERSION_CODE
#include <stdio.h>
#include <stddef.h>
#include <unistd.h>
#endif

/******************************************************************************************
 * PRE DEFINED STRINGS
 *****************************************************************************************/
<#
	foreach(var item in ctx.IndexedNames) {
		var key = item.Key;
		var value = item.Value;
		var inst_name = $"str_inst_{value:x4}";
#>
static const char <#= inst_name #>[] = "<#= key #>";
<#
	}
#>

/******************************************************************************************
 * NON-VOLATILE (but not to expose) SDO OBJECT TYPE DEFINITIONS
 *****************************************************************************************/
<# 	///<summary> 
	/// SDO OBJECT VAR
	///</summary>
	foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose) {
		var typeDef = item.TypeDef;
#>
typedef <#= typeDef #>;
<#
}
#>

<# 	///<summary> 
	///sdo object record
	///</summary>
	foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		foreach(var e in item.Entries) {
			if(e.DataRef == "NULL")
				continue;
			var type_entry = e.RecordTypeEntry;
#>
  <#= type_entry #>;
<#
		} // end of foreach(var e in item.Entries)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose)
#>

<#
	///<summary>
	/// SDO OBJECT ARRAY
	///</summary>
	foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose) {
		var type_def = item.TypeName;
		var struct_name = item.StructName;
#>
typedef struct <#= struct_name #> {
<#
		var entriesCount = item.Entries.Count;
		for(int sub_idx = 0; sub_idx < entriesCount; sub_idx++) {
			if(sub_idx==0 && item.Entries[sub_idx].DataRef == "NULL") {
				continue;
			} 
			if(sub_idx>1) {
				continue;
			}
			var type_entry = sub_idx == 0 ? item.Entries[sub_idx].RecordTypeEntry : $"{item.Entries[sub_idx].ArrayTypeEntry}[{entriesCount-1}]";
#>
  <#= type_entry #>;
<#
		} // end of for(int sub_idx = 0; sub_idx < item.Entries.Count; sub_idx++)
#>
} <#= type_def #>;

<#
	} // end of foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose)
#>

/******************************************************************************************
 * NON-VOLATILE (but not to expose) SDO OBJECT INSTANCE IMPLEMENTATIONS
 *****************************************************************************************/
// sdo var
<#  	// sdo var
	foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = <#= item.Entry.InitValue #>; 
<#
	} // end of foreach(var item in ctx.SdoObjVarNonVolatileButNotExpose)
#>
// sdo records
<# 	// sdo record
	foreach(var item in ctx.SdoObjRecordNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = {
<#
		foreach(var sub in item.Entries) {
			if(sub.DataRef == "NULL")
				continue;
			var inst_name = sub.InstName;
			var init_value = sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>
// sdo array
<#	// sdo array
	foreach(var item in ctx.SdoObjArrayNonVolatileButNotExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
static <#= type_name #> <#= inst #> = {
<#
		for(int sub_idx = 0; sub_idx < 2; sub_idx++) {
			var sub = item.GetEntries()[sub_idx];
			if(sub_idx == 0 && sub.DataRef == "NULL") 
				continue;
			var inst_name =  sub_idx == 1 ? "elements" : sub.InstName;
			var init_value = sub_idx == 1 ? item.ArrayElementsInit : sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>


/******************************************************************************************
 * NON-VOLATILE (exposed) SDO OBJECT INSTANCE IMPLEMENTATIONS
 *****************************************************************************************/
// sdo var
<#
	foreach(var item in ctx.SdoObjVarToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
<#= type_name #> <#= inst #> = <#= item.Entry.InitValue #>; 
<#
	} // end of foreach(var item in ctx.SdoObjVarToExpose)
#>

// sdo records
<#
	foreach(var item in ctx.SdoObjRecordToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
const <#= type_name #> <#= inst #> = {
<#
		foreach(var sub in item.Entries) {
			if(sub.DataRef == "NULL")
				continue;
			var inst_name = sub.InstName;
			var init_value = sub.InitValue;
#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjRecordToExpose)
#>
// sdo array
<#	// sdo array
	foreach(var item in ctx.SdoObjArrayToExpose) {
		var type_name = item.TypeName;
		var inst = item.InstId;
#>
const <#= type_name #> <#= inst #> = {
<#
		for(int sub_idx = 0; sub_idx < 2; sub_idx++) {
			var sub = item.GetEntries()[sub_idx];
			if (sub_idx == 0 && sub.DataRef == "NULL")
				continue;
			var inst_name =  sub_idx == 1 ? "elements" : sub.InstName;
			var init_value = sub_idx == 1 ? item.ArrayElementsInit : sub.InitValue;

#>
	.<#= inst_name #> = <#= init_value #>,
<#
		} // end of foreach(var sub in item.Entries)
#>
};

<#
	} // end of foreach(var item in ctx.SdoObjectsNonVolatileButNotExpose)
#>


/******************************************************************************************
 * OBJECT DESCRIPTIONS
 *****************************************************************************************/
<#
	foreach(var obj in ctx.SdoObjects) {
		var entries = obj.GetEntries();
#>
const obj_desc_t <#= obj.SdoInstName #>[] = {
<#
		foreach(var e in entries) {
#>
	{ .subindex = <#= $"0x{e.SubIdx:x2}" #>, .datatype= <#= e.CANOpenDataType #>, .bitlength = <#= $"0x{e.BitSize:x2}" #>, .name = <#= e.StrInstName #>, .flags = <#= e.AccessType #>, .value = <#= $"0x{e.Value:x8}" #>, .data = <#= e.DataRef #>   },
<#
		} // end of foreach(var e in entries)
#>
};
<#
	} // end of foreach(var obj in ctx.SdoObjects)
#>

/******************************************************************************************
 * PRE-DEFINED RECORDS
 *****************************************************************************************/
const obj_list_t sdo_objects[] = {
<#
	foreach(var item in ctx.SdoObjects) {

#>
  { .index = <#= $"0x{item.Index:x4}" #>, .objtype = <#= item.ObjectType #>, .maxsub = <#= item.MaxSubIndex #>, .pad1 = 0, .name = <#= item.StrInstName #>, .objdesc = sdo_<#= $"{item.Index:x4}"#> },
<#
	} // end of foreach(var item in ctx.SdoObjects)
#>
};

/******************************************************************************************
 * SDO ENTRY MAP
 *****************************************************************************************/
typedef struct entry_addr_map {
	uint16_t index;
	uint8_t subindex;
	uint32_t addr;
	ssize_t size;
	uint8_t *const data;
} entry_addr_map_t;

static const entry_addr_map_t sdo_entry_map[] = {
<#
	foreach(var item in ctx.SdoObjectsNonVolatile) {
		var entries = item.GetEntries();
		foreach(var e in entries) {
			var non_volatile = e.NonVolatile;
			if (!non_volatile) {
				continue;
			}
#>
	{ .index = <#= $"0x{item.Index:x4}" #>, .subindex = <#= $"0x{e.SubIdx:x2}" #>, .addr = <#=  $"0x{(e.Addr32/8):x4}" #>, .size = <#= $"0x{e.BitSize/8:x4}" #>, .data = <#= e.DataRef #> },
<#
		} // end of foreach(var e in entries)
	} // end of foreach(var item in ctx.SdoObjects)
#>
};

#include <string.h>
void sdo_restore_defaults(void)
{
	for (int i = 0; i < SDO_OBJECTS_COUNT; i++) {
		const obj_list_t *const sdo_obj = &sdo_objects[i];
		for (int j = 0; j < sdo_obj->maxsub; j++) {
			const obj_desc_t *const entry = sdo_obj->objdesc + j;
			if (entry->data != NULL) {
				// restore default value
				memcpy((void *)entry->data, &entry->value, entry->bitlength / 8);
			}
		}
	}
}

void sdo_restore_defaults_index(uint16_t index)
{
	const obj_list_t *const sdo_obj = &sdo_objects[index];
	for (int j = 0; j < sdo_obj->maxsub; j++) {
		const obj_desc_t *const entry = sdo_obj->objdesc + j;
		if (entry->data != NULL) {
			// restore default value
			memcpy((void *)entry->data, &entry->value, entry->bitlength / 8);
		}
	}
}

void sdo_restore_defaults_subindex(uint16_t index, uint8_t subindex)
{
	const obj_list_t *const sdo_obj = &sdo_objects[index];
	const obj_desc_t *const entry = sdo_obj->objdesc + subindex;
	if (entry->data != NULL) {
		// restore default value
		memcpy((void *)entry->data, &entry->value, entry->bitlength / 8);
	}
}

void sdo_objects_save_to_storage(struct fs_file_t *file)
{
	for (int i = 0; i < sizeof(sdo_entry_map) / sizeof(entry_addr_map_t); i++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[i];
#ifdef ZEPHYR_VERSION_CODE
		fs_seek(file, entry->addr, FS_SEEK_SET);
		fs_write(file, entry->data, entry->size);
#else
		fseek(file->file_p, entry->addr, SEEK_SET);
		fwrite(entry->data, 1, entry->size, file->file_p);
#endif
	}
}

void sdo_objects_init_from_storage(struct fs_file_t *file)
{
	for (int i = 0; i < sizeof(sdo_entry_map) / sizeof(entry_addr_map_t); i++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[i];
#ifdef ZEPHYR_VERSION_CODE
		fs_seek(file, entry->addr, FS_SEEK_SET);
		fs_read(file, entry->data, entry->size);
#else
		fseek(file->file_p, entry->addr, SEEK_SET);
		fread(entry->data, 1, entry->size, file->file_p);
#endif
	}
}



static ALWAYS_INLINE int16_t search_sdo_map(uint16_t index, uint8_t subindex)
{
	int low = 0; 
	int mid = <#= ctx.SdoEntriesNonVolatileCount/2 #>;
	int high = <#= ctx.SdoEntriesNonVolatileCount-1 #>;

	for (int iter = 0; iter < <#= ctx.SdoEntriesNonVolatileCountLog2Up #>; iter++) {
		const entry_addr_map_t *const entry = &sdo_entry_map[mid];
		if (entry->index == index && entry->subindex == subindex) {
			return mid;
		} else if (entry->index < index || (entry->index == index && entry->subindex < subindex)) {
			low = mid + 1;
		} else {
			high = mid - 1;
		}
		mid = (low + high) / 2;
	}
	return -1;
}

int sdo_object_save_to_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex)
{
	// find index/subindex in the map
	int16_t sdo_map_idx = search_sdo_map(index, subindex);
	if (sdo_map_idx < 0) {
		return -1;
	}
	const entry_addr_map_t *const entry = &sdo_entry_map[sdo_map_idx];
	int ret = 0;

#ifdef ZEPHYR_VERSION_CODE
	ret = fs_seek(file, entry->addr, FS_SEEK_SET);
#else
	ret = fseek(file->file_p, entry->addr, SEEK_SET);
#endif

	if (ret) {
		goto fail_or_default;
	}

#ifdef ZEPHYR_VERSION_CODE
	ret = fs_write(file, entry->data, entry->size);
#else
	ret = fwrite(entry->data, 1, entry->size, file->file_p);
#endif

fail_or_default:
	return ret;
}

/**
 * @brief Load sdo entry from index-subindex pair
 *
 * @param file
 * @param index
 * @param subindex
 * @return int
 */
int sdo_object_load_from_storage(struct fs_file_t *file, uint16_t index, uint8_t subindex)
{
	int16_t sdo_map_idx = search_sdo_map(index, subindex);
	if (sdo_map_idx < 0) {
		return -1;
	}
	const entry_addr_map_t *const entry = &sdo_entry_map[sdo_map_idx];
	int ret = 0;
#ifdef ZEPHYR_VERSION_CODE
	ret = fs_seek(file, entry->addr, FS_SEEK_SET);
#else
	ret = fseek(file->file_p, entry->addr, SEEK_SET);
#endif
	if (ret) {
		goto fail_or_default;
	}
#ifdef ZEPHYR_VERSION_CODE
	ret = fs_read(file, entry->data, entry->size);
#else
	// ret = read(file->fd, entry->data, entry->size);	
	ret = fread(entry->data, 1, entry->size, file->file_p);
#endif

fail_or_default:
	return ret;
}

// clang-format on
